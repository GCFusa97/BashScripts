1) Assignment:
 1. Write a bash script that automatically generates a report of all installed packages on a Linux system.
 2. Use the iptables command to set up a firewall that blocks incoming connections on specific ports but allows outgoing connections.
 3. Write a bash script that monitors the CPU usage of a specific process and terminates it if it exceeds a certain threshold.
 4. Use the rsync command to perform incremental backups of a directory, excluding specific files or directories.

2) Assignment:
 1. Write a bash script that monitors the disk space of multiple partitions and sends an email notification if any of them exceed a specified threshold.
 2. Use the tcpdump command to capture network traffic on a specific interface and save it to a file for analysis.
 3. Write a bash script that monitors the status of a specific service and automatically restarts it if it crashes or becomes unresponsive.



1) Assignment

1.
************************************************************************************** 
#!/bin/bash

dpkg-query -f '${Package}\t${Version}\n' -W > package_report.txt

echo "Package report generated."
**************************************************************************************


2.
**************************************************************************************
First I clear any firewall rules

# Deletes all rules in the filter table
iptables -F 

# Set default policy to allow outcoing connections and block incoming connections (block all incoming traffic)
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow incoming connections only on port 80
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# To make the changes persistent over reboots
sudo service iptables save

# In order to test, I create a dummy_file.txt with some content and start a server to listen on incoming traffic on port 80
sudo python3 -m http.server 80

# After that, on the host OS(windows) in powershell, initiate a telnet connection to the IP of the WSL instance and port 80
telnet <WSL_IP_ADDRESS> 80

# Once connected, I set a HTTP GET request to fetch the dummy_file.txt
GET /dummy_file.txt HTTP/1.1
Host: localhost

# After enter, the server responded with the content of the file. This means that connections on port 80 work,
  as opposed to the ping to <WSL_IP_ADDRESS> for instance. So, I only accept traffic on port 80.
**************************************************************************************


3.
**************************************************************************************
#!/bin/bash


# Read process name and threshold from user
read -p "Please enter process name to monitor: " process_name
read -p "Please enter threshold for CPU usage: " cpu_threshold

# Pull pid of the process
pid=$(pgrep "$process_name")


# Enter monitoring loop -> check if process is running, if yes compare CPU usage with threshold -> terminate process if cpu_usage > threshold
while true; do
  if [ -n "$pid" ]; then
    cpu_usage=$(ps -p "$pid" -o %cpu | awk 'NR==2')
    if [[ "$cpu_usage" -gt "$cpu_threshold" ]]; then
      echo "Threshold exceeded for CPU usage, temrinating process "$process_name"!"
      kill "$pid"
      break
    fi
  else
    echo "Process "$process_name" not running!"
    break
  fi
  sleep 1
done  

**************************************************************************************



4.
**************************************************************************************
rsync -av --exclude 'file.txt' --exclude 'dir/' /path/to/source/ /path/to/destination/
**************************************************************************************



2) Asignment

1.
**************************************************************************************
#!/bin/bash

read -p "Please enter threshold for disk space: " threshold

recipient="recipient@example.com"
sender="sender@example.com"

send_mail() {
  
  subject="Disk space alert!"
  body="Disk partition "$1" has exceeded imposed threshold "$2"!"

  echo -e "$body" | mail -s "$subject" -r "$sender" "$recipient" 
}

partitions=("/dev/sda1" "/dev/sdb1" "/dev/sdc1")

for partition in "$partitions[@]"; do
  usage=$(df | grep "$partition" | awk '{print $5}' | tr -d "%")
  
  if [[ "$usage" -gt "$threshold" ]; then
    send_email "$partition" "$usage"
  fi
done
**************************************************************************************

2.
**************************************************************************************
I am running Ubuntu with WSL and monitored eth0 network interface with tcpdump as I sent a ping ip -t from my host os.

sudo tcpdump -i eth0 > tcpdump.txt

The output looks like this: 


22:19:22.420704 IP DESKTOP-PTSLPGI.mshome.net > static-172-25-60-53.rdsnet.ro: ICMP echo request, id 1, seq 41, length 40
22:19:22.420759 IP static-172-25-60-53.rdsnet.ro > DESKTOP-PTSLPGI.mshome.net: ICMP echo reply, id 1, seq 41, length 40
22:19:22.571544 IP static-172-25-60-53.rdsnet.ro.33236 > DESKTOP-PTSLPGI.mshome.net.domain: 43659+ PTR? 53.60.25.172.in-addr.arpa. (43)
22:19:22.578055 IP DESKTOP-PTSLPGI.mshome.net.mdns > 224.0.0.251.mdns: 0 PTR (QM)? 53.60.25.172.in-addr.arpa.local. (49)
22:19:22.580637 IP6 DESKTOP-PTSLPGI.mdns > ff02::fb.mdns: 0 PTR (QM)? 53.60.25.172.in-addr.arpa.local. (49)
22:19:22.598560 IP DESKTOP-PTSLPGI.mshome.net.domain > static-172-25-60-53.rdsnet.ro.33236: 43659- 1/0/0 PTR static-172-25-60-53.rdsnet.ro. (111)

This lines capture some packed headers related to the IP layer, like id, seq, length

Finally, I got this output

557 packets captured
557 packets received by filter
0 packets dropped by kernel
**************************************************************************************



3.
**************************************************************************************
#!/bin/bash

read -p "Please enter service name: " service_name

service_running(){
  pgrep -f "$service_name" >/dev/null  
}

restart_service(){
  echo "[$(date +'%Y-%m-%d %H:%M:%S')] Restarting "$service_name"" >> service_log_file.txt
  systemctl restart "$service_name"
}

while true; do
  if ! service_running; then
    restart_service
  fi 
  sleep 5
done
**************************************************************************************
